<?php
namespace rxlwin\view;//1.声明类的命名空间 2.由composer规范,以实现自动加载,自由调用

/**
 * 模板加载类,此类写在框架文件夹下的view目录中.这是因为这个通用型的类,几乎所有应该类中的方法加载模板文件时都要使用此方法,所以此方法的书写一定要简单易用.所以我们采用的拦截器实现了静态与非静态两种调用方法的实现.
 * Class View
 * @package myself\view
 */
class View{
    /**
     * 拦截器 __call 当外部实例化本类,并调用一个本类和基类都不存在的方法时,触发本方法,因为本类中没有其他方法,所以只要外部调用本类的任意方法,都会触发两个方法中的一个.
     * @param $name 外部调用的没有找到的方法名
     * @param $arguments 调用方法时所带的参数
     * @return mixed 这此我们直接返回了调用本类下run方法所返回的内容
     *
     *   * 使用本方法的用意:
     * 我们终极目的是为了调用Base类中的$name方法,但是调用方法比较繁琐,举例如下
     * $obj = new Base();
     * $obj -> make();
     * 在以上代码中,我们实例化了Base类,并调用了make方法,以后代码量大了,出错的可能性会增加,调试也会降低效率.
     * 所以我们加入了Veiw类,使用Veiw类的拦截器,我们实现了Base类的简单调用.
     * 将简化到了极致.简化后的代码变成了:
     * (new View)->make();
     * 想出这个办法的人,简直就是神一样的存在.
     */
    public function __call($name, $arguments)
    {
        //1.静态调用run方法并返回 2.因为这里有代码重用,所以我们又封装了一个方法用来调用
        return self::run($name, $arguments);
    }

    /**
     * 静态方法拦截器 __callStatic 当外部静态调用应用模型类中一个本类和基类都不存在的方法中,触发本方法
     * @param $name 外部调用的没有找到的方法名
     * @param $arguments 调用方法时所带的参数
     * @return mixed 这此我们直接返回了调用run方法所返回的内容
     *
     *      * 使用本方法的用意:
     * 在应用中除了上面的正常实例化后再调用的办法,我们还可以更简化,使用静态调用同时也实现了方法的两种方式调用
     * 思想与上面常规方法是一致的,只是静态调用代码更简单
     * 例如上面的例子中我们代码可以再简化成如下代码:
     * View::make();
     * 当应用中这个调用make()方法时,就会触发本方法,通过本方法再实例化Base类,再调用Base中的make方法
     * 这次是真的到极致了.以我的脑子,再想不出还能怎么简化了.再次感叹神一般的大牛存在.献上我的膝盖
     */
    public static function __callStatic($name, $arguments)
    {
        //1.静态调用run方法并返回 2.因为这里有代码重用,所以我们又封装了一个方法用来调用
        return self::run($name, $arguments);
    }

    /**
     * 封装的用来实例化Base类并调用其方法的方法
     * @param $name 外部调用的没有找到的方法名
     * @param $arguments 调用方法时所带的参数
     * @return mixed 调用Base类下$name方法时的返回值,我们原封不动的全部返回去
     */
    private static function run($name, $arguments){
        //1.使用call_user_func_array函数调用Base中的$name方法 2.这里使用函数调用而不是直接调用,主要的原因在后面的参数上,如果直接调用,参数可能会混乱,而使用此函数进行方法调用,此函数会自动根据方法所需要的参数类型转换.兼容率更高.(再详细解释一下,方法中有时是用数据做参数,有时使用字符串做参数,而在使用字符串做参数时,可能会使2个或更多的字符串,因为我们调用时,是使用的魔术方法来进行调用的,参数经过几次转手,已经统一都变成了数组类型,这时,如果我们直接调用时($obj->method($arguments)),参数的数量和类型就很可能会出错了;而这个函数就会把我们调用时使用的参数类型准备好,根据所调用方法需要的类型转换,最终成功调用)
       return call_user_func_array([new Base(),$name],$arguments);
    }
}