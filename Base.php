<?php
namespace rxlwin\view;//1.声明类的命名空间 2.由composer规范,以实现自动加载,自由调用

/**
 * 加载应用类模板的核心类,主要的加载都是从这里实现,而同一文件夹内的View类,只是为更加方便的调用此类中的方法而建立的
 * Class Base
 * @package myself\view
 */
class Base{
    //1.声明私有属性 2.这些私有属性的声明只有一个作用,就是为了在类中全局使用.
    private $data=[];
    private $path;

    /**
     * 组合模板路径的方法
     * @return $this
     */
    public function make(){
        //1.组合出模板的完整路径 2.为最后加载模板作准备
        $path="../app/".MODULE."/view/".CONTROLLER."/".ACTION.".php";
        //1.将组合好的完整路径字符串赋值给本类下的私有属性 2.最后加载模板是使用本类下的其他方法,所以需要将内容赋值给应用范围更广的属性
        $this->path=$path;
        //1.将本对象作为返回值返回 2.这一招我非常膜拜,一石二鸟,其一,实现了链式操作(返回了对象,调用本方法的地方就变成了对象,又可以再接着调用本对象下的其他方法).其二,我们要实现模板的最后加载,使用了__toString方法,这个方法比较特殊,是当echo一个对象时,会触发此方法,所以这里我们返回一个对象,以后就好触发__toString方法了.
        return $this;
    }

    /**
     * 给模板传递其需要的参数
     * @param $data 调用时传递来的参数
     * @return $this 返回本对象
     */
    public function with($data){
        //1.将传递来的参数直接赋值给本类的私有属性 2.2.最后加载模板是使用本类下的其他方法,所以需要将内容赋值给应用范围更广的属性
        $this->data=$data;
        //1.将本对象作为返回值返回 2.理由同上一方法
        return $this;
    }

    /**
     * 本方法用以加载模板,此方法是一个魔术方法,触发条件是当输出本对象时触发,所以我们最终需要echo这个对象
     * @return string 在本方法中我们不需要输出内容,所以我们返回一个空字符
     */
    public function __toString()
    {
        //1.将传来的参数恢复成压缩前的参数状态 2.这样传递参数前的变量,现在继续是什么变量,保持了变量名称和内容的一致性
        extract($this->data);
        //1.加载模板文件 2.前面所有的准备,就为这一刻,模板的最终显示就在这里实现
        include $this->path;
        //1.返一个空字符串 2.这也是这个方法的怪癖,要求必须返回一个字符串,而我们这里的确没有什么好返回的东西,那就返回一个空字符串.
        return "";
    }
}